---
tags:
  - 算法
  - 链表
---
# 链表

## 双指针

#### [【2】 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

方法：双指针

思路：

题解：

```java
class Solution {
  
    /**
     * 注意进位
     * @param l1 链表1
     * @param l2 链表2
     * @return 和的链表
     */
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        // 定义p1、p2 两个指针分别指向两个链表头节点
        ListNode p1 = l1, p2 = l2;
        // 定义第三个链表的虚拟头结点，以及指向这个虚拟头结点的指针
        ListNode dummyHead = new ListNode(-1);
        ListNode p = dummyHead;
        int carry = 0;

        while (p1 != null || p2 != null) {
            int v1 = p1 != null ? p1.val : 0;
            int v2 = p2 != null ? p2.val : 0;
            int tempValue = v1 + v2 + carry;
            // 计算新值与进位
            int newValue = tempValue % 10;
            carry = tempValue / 10;
            p.next = new ListNode(newValue);

            // 指针后移
            if (p1 != null) {
                p1 = p1.next;
            }
            if (p2 != null) {
                p2 = p2.next;
            }
            p = p.next;
        }

        // 补上最后的进位
        if (carry != 0) {
            p.next = new ListNode(carry);
        }
        return dummyHead.next;
    }
}

```

###### [【19】 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

方法：双指针

思路：

题解：

```java
class Solution {

    /**
     * 方法：双指针
     * <p>
     * （1）两趟扫描
     * 首先很容易想出两趟扫描的方法，先扫描一趟，获取链表的size，再扫描一趟，定位到目标结点的前驱结点，然后删除即可。
     * <p>
     * （2）一趟扫描
     * 要使用一趟扫描来实现的话，可以使用双指针，利用虚拟头结点，当右指针指到尾结点下一个结点的时候，左指针刚好指到目标结点的前驱结点
     *
     * @param head
     * @param n
     * @return
     */
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 定义左指针，指向链表的虚拟头结点
        ListNode dummy = new ListNode(0, head);
        ListNode l = dummy;
        // 定义右指针，指向
        ListNode r = head;
        for (int i = 0; i < n ; i++) {
            r = r.next;
        }

        // 将右指针移到尾结点的下一个结点，此时左指针刚好指向目标结点的前驱
        while(r!=null){
            l=l.next;
            r=r.next;
        }

        // 删除倒数第n个结点
        l.next = l.next.next;
        return dummy.next;
    }
}

```

## 分治

#### [【21】 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

方法：迭代

思路：

题解：

```java
class Solution {

    /**
     * 方法：迭代
     *
     * @param l1
     * @param l2
     * @return
     */
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(-1);
        ListNode p = dummy;
        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                p.next = new ListNode(l1.val);
                l1 = l1.next;
            } else {
                p.next = new ListNode(l2.val);
                l2 = l2.next;
            }
            p = p.next;
        }

        while (l1 != null) {
            p.next = new ListNode(l1.val);
            p = p.next;
            l1 = l1.next;
        }
        while (l2 != null) {
            p.next = new ListNode(l2.val);
            p = p.next;
            l2 = l2.next;
        }

        return dummy.next;
    }


    /**
     * 方法：迭代
     * 通过原地调整链表来优化空间复杂度
     *
     * @param l1
     * @param l2
     * @return
     */
    public ListNode mergeTwoLists2(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(-1);
        ListNode p = dummy;
        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                p.next = l1;
                l1 = l1.next;
            } else {
                p.next = l2;
                l2 = l2.next;
            }
            p = p.next;
        }

        p.next = l1 != null ? l1 : l2;
        return dummy.next;
    }
}
```

#### [【23】 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

方法：分治

思路：

题解：

```java
    /**
     * 方法： 分治合并
     * 很容易联想到前面 【21. 合并两个有序链表】 这一题，
     * 那么将K个升序链表两两配对，然后使用 lc21 的方法两两合并，不断重复这个步骤，即可得出最终结果
     *
     * @param lists
     * @return
     */
    public ListNode mergeKLists(ListNode[] lists) {
        return merge(lists, 0, lists.length - 1);
    }

    public ListNode merge(ListNode[] lists, int l, int r) {
        if (l == r) {
            return lists[l];
        }
        if (l > r) {
            return null;
        }
        int mid = l + ((r - l) >> 1);
        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
    }

    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(-1);
        ListNode p = dummy;
        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                p.next = l1;
                l1 = l1.next;
            } else {
                p.next = l2;
                l2 = l2.next;
            }
            p = p.next;
        }

        p.next = l1 != null ? l1 : l2;
        return dummy.next;
    }
}
```

## 二叉树展开为链表

#### [【114】 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

方法：递归

思路：

题解：

> - [二叉树展开为链表_官方题解](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu/)

```java
class Solution {

    /**
     * 先暂存左右子树，然后分别将左右子树展平，然后将根的左子树置空，将展平后的原左子树挂到根的右子树上，
     * 接着指针后移到右子树最右节点，然后将展平后的原右子树挂到最右节点的右子树上
     * @param root 根节点
     */
    public void flatten(TreeNode root) {
        if (root == null) {
            return;
        }

        // 暂存左子树，右子树
        TreeNode left = root.left;
        TreeNode right = root.right;

        // 递归，将左/由子树分别展平（展开为链表）
        flatten(left);
        flatten(right);

        // 将根的 left 置空，并将展平后的 left 挂到右子树上
        root.left = null;
        root.right = left;

        // 找到新的右子树的叶子节点，并将原右子树展平后得到的树挂到这个叶子节点的右子树上
        TreeNode p = root;
        while (p.right != null) {
            p = p.right;
        }
        p.right = right;
    }

}
```

## 环形链表

#### [【141】 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

方法：双指针

思路：先设置快慢指针，若慢指针追上快指针，则链表有环。

题解：

```java
/**
 * title: 141. 环形链表 - 判断是否有环
 *
 * @author shira 2019/07/09 22:57
 */
class Solution {

    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }

        // 设置快慢指针初始值
        ListNode slow = head;
        ListNode fast = head.next;

        // 第一次相遇点
        while (fast != slow) {
            if (fast == null || fast.next == null) {
                return false;
            }
            slow = slow.next;
            fast = fast.next.next;
        }

        return true;
    }
}

```

#### [【142】 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

方法：双指针

思路：

设置快慢指针 fast 与 slow，起始时位于链表头部，随后 fast 每次向后移动两步，slow 每次移动一步，如果链表中存在环，则快慢指针最终将在环中相遇。

如下图所示，设链表环外部分的长度为 a，slow 指针进入环后，又走了 b 的距离与 fast 相遇，环的剩余部分长度为 c，此时 fast 指针已经走完了环的 n 圈。

![链表](./images/01-链表/142_fig1.png)


则 **快慢指针在环中第一次相遇时，a = c**：

> - fast 走过的总距离为 `a + n(b + c) + b  => a + (n + 1)b + nc`
> - slow 走过的总距离为 `a + b`
> - 而 fast 走过的距离为 slow 的两倍，`a + (n + 1)b + nc  = 2(a + b) =>  a = c + (n - 1)(b + c)`
> - 我们考虑最简单的情况 n=1，也即快慢指针在环中第一次相遇时，a = c.

因此，当快慢指针第一次相遇时，再额外设置一个指针p，它指向链表头部；随后，它和 slow 每次向右移动一个位置。最终，它们会在入环点相遇。

题解：

> - [环形链表 II_官方题解](https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/)

```java
/**
 * title: 142. 环形链表 II - 查找入环节点
 *
 *  思路：快慢指针在环中第一次相遇时，a = c
 *
 * @author shira 2019/07/09 22:57
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) {
            return null;
        }
        // 设置快慢指针初始值
        ListNode slow = head.next;
        ListNode fast = head.next.next;

        // 第一次相遇点
        while (slow != fast) {
            if (fast == null || fast.next == null) {
                return null;
            }
            slow = slow.next;
            fast = fast.next.next;
        }

        // 将fast移到链表头，并且fast 和slow从此时开始每次向后移动一个位置，最终相遇点即为入环点
        fast = head;
        while (fast != slow) {
            slow = slow.next;
            fast = fast.next;
        }
        return slow;
    }
}

```
