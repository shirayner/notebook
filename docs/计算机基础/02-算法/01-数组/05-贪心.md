---
tags:
  - 算法
  - 贪心
---
# 贪心

##### [【55】跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

方法：贪心算法

思路：不断更新每次能到达的最远距离

题解：

```java
class Solution {

    public boolean canJump(int[] nums) {
        // 每次到达一个位置时，便更新本次能到达的最远位置
        int rightMost = nums[0];
        for(int i=0; i<nums.length; i++){
            if(rightMost < i){
                // 如果到不了当前位置，则退出
                return false;
            }
            // 更新本次能到达的最远位置
            rightMost = Math.max(i + nums[i], rightMost);
            if(rightMost >= nums.length -1){
                // 如果能到达最后一个位置，则退出
                return true;
            }
        }
        return false;
    }

}
```

##### [【56】 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

方法：贪心算法

思路：先按左端点排序，然后将第一个区间加入合并区间，然后不断更新右端点，若当前区间的左端点大于合并区间的右端点，区间无重叠，需开辟新的合并区间

题解：

```java
class Solution {

    public int[][] merge(int[][] intervals) {
        // 排序
        Arrays.sort(intervals, (v1, v2) -> v1[0] - v2[0]);

        int[][] ans = new int[intervals.length][2];
        int idx = -1;
        for (int i = 0; i < intervals.length; i++) {
            if (idx == -1 || intervals[i][0] > ans[idx][1]) {
                // 当是第一个元素或者当前区间左端点大于合并区间右端点时，开辟新区间
                ++idx;
                ans[idx][0] = intervals[i][0];
                ans[idx][1] = intervals[i][1];
            } else {
                // 不断更新右端点最大值
                ans[idx][1] = Math.max(ans[idx][1], intervals[i][1]);
            }
        }

        // 因为 ans 数组的实际长度可能小于初始容量 intervals.length，没填满的位置会用0填充
        // 为了去掉这些0的位置，我们干脆用数组长度复制出一个新数组
        return Arrays.copyOf(ans, idx + 1);
    }

}
```
