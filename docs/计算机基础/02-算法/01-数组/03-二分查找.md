---
tags:
  - 算法
  - 二分查找
---
# 二分查找

二分查找常见题型：

> - 二分查找目标值
> - 二分查找左右边界
> - 分段区间二分查找

题眼：

> - 时间复杂度为 `O(log n)`
> - 

### [【33】搜索旋转排序数组 ](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

方法：二分查找

思路： 分段区间二分查找

题解：

> - [一文带你刷遍二分查找（视频+绘图）](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/yi-wen-dai-ni-shua-bian-er-fen-cha-zhao-dtadq/)
> - [搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/sou-suo-xuan-zhuan-pai-xu-shu-zu-by-leetcode-solut/)
> - 

```java
/**
 * title: 33. 搜索旋转排序数组
 *
 * @author shira 2019/07/09 22:57
 */
class Solution {

    public int search(int[] nums, int target) {
        int left = 0, right = nums.length - 1, mid = 0, n = nums.length;
        if (n == 0) {
            return -1;
        }
        if (n == 1) {
            return nums[0] == target ? 0 : -1;
        }
        while (left < right) {
            mid = left + ((right - left) >> 1);
            if (nums[mid] == target) {
                return mid;
            }
            // 数组由两段升序数组组成 [0,k], [k+1, n-1]
            if (nums[mid] >= nums[0]) {
                //说明mid落在升序区间： [0, mid)∪(mid,k],故[left, mid] 有序
                if (nums[0] <= target && target < nums[mid]) {
                    // 若 target落在升序区间[left, mid)
                    right = mid - 1;
                } else if (target < nums[0] || nums[mid] < target) {
                    // 若 target落在 [k+1, n-1] 或者(mid,k] 上
                    left = mid + 1;
                }
            } else if (nums[mid] < nums[0]) {
                //说明mid落在[k+1, n-1], 故[mid, right]有序
                if (nums[mid] < target && target <= nums[n - 1]) {
                    // 若 target落在升序区间[mid, right]
                    left = mid + 1;
                } else if (target < nums[mid] || target > nums[n - 1]) {
                    // 若 target落在 [k+1, mid) 或者 [0,k] 上
                    right = mid - 1;
                }
            }
        }
        return nums[left] == target ? left : -1;
    }


    /**
     * 有序数组的基础二分查找法
     *
     * @param nums   有序数组
     * @param target 目标值
     * @return
     */
    public int binarySearchBase(int[] nums, int target) {
        int left = 0, right = nums.length - 1, mid = 0;
        while (left <= right) {
            mid = left + ((right - left) >> 1);
            if (nums[mid] < target) {
                // 向右逼近: [mid+1, right]
                left = mid + 1;
            } else if (nums[mid] > target) {
                // 向左逼近：[left, mid -1]
                right = mid - 1;
            } else if (nums[mid] == target) {
                return mid;
            }
        }
        return -1;
    }

    /**
     * 有序数组的寻找左侧边界的二分查找法
     *
     * @param nums   包含重复值的有序顺序
     * @param target 目标值
     * @return
     */
    public int binarySearchLeftBound(int[] nums, int target) {
        int left = 0, right = nums.length - 1, mid = 0;
        while (left < right) {
            mid = left + ((right - left) >> 1);
            if (nums[mid] < target) {
                // 向右逼近: [mid+1, right]
                left = mid + 1;
            } else if (nums[mid] > target) {
                // 向左逼近：[left, mid -1]
                right = mid - 1;
            } else if (nums[mid] == target) {
                // 寻找左侧边界，mid可能就是左侧边界，因此下一轮搜索区间为：[left, mid]
                right = mid;
            }
        }
        return nums[left] == target ? left : -1;
    }

    /**
     * 有序数组的寻找右侧边界的二分查找法
     *
     * @param nums   包含重复值的有序顺序
     * @param target 目标值
     * @return
     */
    public int binarySearchRightBound(int[] nums, int target) {
        int left = 0, right = nums.length - 1, mid = 0;
        while (left < right) {
            // （1）整除是向下取整, 因此对于 mid = left + ((right - left) >> 1) 来说中间位置是偏左的,
            // 这样在最后 left和right相邻时, mid偏左会导致 left 和 mid 指向同一个位置, right 指向下一个位置,
            // 在nums[left]已经等于目标值的情况下, 这三个位置的值都不会更新, 从而进入了死循环.
            // （2）所以我们应该让mid偏右，这样left就能向右移动。因此改为 mid = left + ((right - left) >> 1) + 1
            // （3）查找条件，判断条件和左右边界的更新方式三者之间需要配合使用。
            mid = left + ((right - left) >> 1) + 1;
            if (nums[mid] < target) {
                // 向右逼近: [mid+1, right]
                left = mid + 1;
            } else if (nums[mid] > target) {
                // 向左逼近：[left, mid -1]
                right = mid - 1;
            } else if (nums[mid] == target) {
                // 寻找右侧边界，mid可能就是右侧边界，因此下一轮搜索区间为：[mid, right]
                left = mid;
            }
        }
        return nums[right] == target ? right : -1;
    }

}


```

### [【34】在排序数组中查找元素的第一个和最后一个位置 ](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

方法：二分查找

思路： 查找左右边界的二分查找，先用一遍二分查找找出左边界，再用一遍二分查找找出右边界即可

做二分查找相关题目时，需要注意几点：

> - 将判断条件分开写
> - 当target == nums[mid]时，判断是否可以取到mid，这样就可以得出是取mid , mid+1 还是 mid -1
> - 

题解：

> - [在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-3-4/)

```java
/**
 * title: 34. 在排序数组中查找元素的第一个和最后一个位置
 *
 * @author shira 2019/07/09 22:57
 */
class Solution {

    public int[] searchRange(int[] nums, int target) {
        int[] result = new int[]{-1, -1};
        // 查询左边界
        int left = 0, right = nums.length - 1, mid = 0;
        while (left < right) {
            mid = left + ((right - left) >> 1);
            if (target < nums[mid]) {
                // 向左逼近
                right = mid - 1;
            } else if (target == nums[mid]) {
                // 目标值可能在左边，故向左逼近
                right = mid;
            } else if (nums[mid] < target) {
                // 向右逼近
                left = mid + 1;
            }
        }
        result[0] = nums[left] == target ? left : -1;

        // 查询右边界
        right = nums.length - 1;
        while (left < right) {
            mid = left + ((right - left) >> 1) + 1;
            if (target < nums[mid]) {
                // 向左逼近
                right = mid - 1;
            } else if (target == nums[mid]) {
                // 目标值可能在右边，故向右逼近
                left = mid;
            } else if (nums[mid] < target) {
                // 向右逼近
                left = mid + 1;
            }
        }
        result[1] = nums[left] == target ? left : -1;
        return result;
    }
}

```

### [【374】猜数字大小](https://leetcode-cn.com/problems/guess-number-higher-or-lower/)

方法：二分查找

思路：

题解：

```java
public class Solution extends GuessGame {

    public int guessNumber(int n) {
        int left = 1, right = n;
        while (left < right) {
            int mid = left + (right - left) / 2;
            int guess = guess(mid);
            if (guess == 0) {
                // pick > mid
                return mid;
            } else if (guess < 0) {
                // pick < mid
                right = mid - 1;
            } else {
                // pick > mid
                left = mid + 1;
            }
        }
        return left;
    }
}
```
