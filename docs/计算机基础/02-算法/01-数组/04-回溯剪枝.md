---
tags:
  - 算法
  - 回溯
  - 剪枝
---
# 回溯 + 剪枝

回溯等效于深度优先搜索(DFS)  + 状态重置，通常需要定义递归函数

常见题型：

> - 重复元素搜索：选择与不选择当前数

题眼：

> - 寻找所有可行解
> - 数据量比较小，通常为几千以内，如：`1 <= candidates.length <= 30`
> - 

##### [【39】组合总和](https://leetcode-cn.com/problems/combination-sum/)

方法：回溯

思路： 可通过画图来确定递归函数

题解：

> - [组合总和](https://leetcode-cn.com/problems/combination-sum/solution/zu-he-zong-he-by-leetcode-solution/)
> - [「手画图解」怎么分析回溯问题？ | 组合总和 combination sum](https://leetcode-cn.com/problems/combination-sum/solution/shou-hua-tu-jie-zu-he-zong-he-combination-sum-by-x/)
> - [回溯算法入门级详解 + 练习（持续更新）](https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/)

```java
/**
 * title: 39. 组合总和
 *
 * @author shira 2019/07/09 22:57
 */
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> combine = new ArrayList<>();
        dfs(candidates, target, 0, combine, result);
        return result;
    }

    private void dfs(int[] candidates, int target, int idx, List<Integer> combine, List<List<Integer>> result) {
        if (idx == candidates.length) {
            // candidates被用完，搜索结束
            return;
        }
        if (target < 0) {
            return;
        }
        if (target == 0) {
            // 找到结果，本次搜索结束
            result.add(new ArrayList<>(combine));
            return;
        }

        // 跳过当前数
        dfs(candidates, target, idx + 1, combine, result);

        if (candidates[idx] <= target) {
            // 选择当前数
            combine.add(candidates[idx]);
            // 继续向后选择剩下的数，由于每个数字可被重复选取，因此下次仍然是从idx开始
            dfs(candidates, target - candidates[idx], idx, combine, result);
            // 撤销对当前数的选择，回到选择candidates[i]之前的状态，继续尝试选同层右边的数
            combine.remove(combine.size() - 1);
        }
    }
}

```

##### [【46】全排列](https://leetcode-cn.com/problems/permutations/)

方法：回溯

思路： 选与不选

题解：

> - [回溯算法入门级详解 + 练习（持续更新）](https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/)

```java
/**
 * 46. 全排列
 *
 * @author r.shi 2021/5/21 17:12
 */
public class Solution {

    public List<List<Integer>> permute(int[] nums) {
        int size = nums.length;
        if (size == 0) {
            return new ArrayList<>();
        }
        // 使用一个动态数组保存所有的路径
        List<List<Integer>> res = new ArrayList<>();

        // 记录某个位置是否被选过
        boolean[] used = new boolean[size];
        // 记录一个路径
        List<Integer> path = new ArrayList<>();

        dfs(nums, size, 0, used, path, res);

        return res;

    }

    /**
     * 第i层dfs即是求第i个位置的数。
     * 假设给定 nums=[1,2,3] 要求其所有可能的全排列。
     * 那么对于第一层dfs：
     * （1）先选择1， 然后在剩下的 2,3中继续求全排列，即得 1 + [2,3] 的全排列：[1,2,3] 和 [1,3,2]
     * （2）然后撤销1的选中状态，也就是回溯，那么第二次for循环先选择2，然后在剩下的 1,3 中继续求全排列，即得 2 + [1,3] 的全排列
     *
     * @param nums
     * @param size
     * @param depth
     * @param used
     * @param path
     * @param res
     */
    private void dfs(int[] nums, int size, int depth, boolean[] used, List<Integer> path, List<List<Integer>> res) {
        if (depth == size) {
            res.add(new ArrayList<>(path));
            return;
        }

        // 每一个位置都有size种可能，因此遍历size次
        for (int i = 0; i < size; i++) {
            // 因为是全排列，所以当某个数字在前面的位置已经被选上了只有，在后面的位置就不能选了
            if (!used[i]) {
                // 选择这个数字
                // 例如第一个位置选中 1
                path.add(nums[i]);
                used[i] = true;

                // 继续在剩下的位置中进行全排列
                // 例如求 [2,3] 的全排列，会得到 [1,2,3] [1,3,2]
                dfs(nums, size, depth + 1, used, path, res);

                // 不选择这个数字，也即回溯，即撤销状态
                // 例如，下一步回溯之后，继续对第一个位置进行选择，第一个位置选择2，那么撤销状态后，后面的位置就可以选1了
                used[i] = false;
                path.remove(path.size() - 1);
            }
        }
    }

}

```

##### [【77】 组合](https://leetcode-cn.com/problems/combinations/)

方法：回溯

思路： 选与不选

题解：

> - [回溯算法 + 剪枝（Java）](https://leetcode-cn.com/problems/combinations/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-ma-/)

```java
/**
 * 77. 组合
 *
 * @author r.shi 2021/5/21 17:12
 */
class Solution {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> res = new ArrayList<>();
        if (k <= 0 || n < k) {
            return res;
        }
        // 从 1 开始是题目的设定
        Deque<Integer> path = new ArrayDeque<>();
        dfs(n, k, 1, path, res);
        return res;

    }

    /**
     * 假设 n=3, k=2, 要返回 1...n中所有可能的k个数的组合。
     * 那么对于第一层dfs：
     * （1）初始时先选中1，然后在 [2..n] 中继续选择k-1个数，即可得 1 + [2..n] 的组合： [1,2] 和 [1,3] , 这里可以看见递归
     * （2）然后撤销1的选中状态,也就是不选择1，也就是回溯，接着第二次for循环先选择2，然后在[3] 中选择一个数，即得 [2,3]
     * @param n
     * @param k
     * @param start
     * @param path
     * @param res
     */
    private void dfs(int n, int k, int start, Deque<Integer> path, List<List<Integer>> res) {
        // 递归终止条件是：path 的长度等于 k
        if (path.size() == k) {
            res.add(new ArrayList<>(path));
            return;
        }

        // 遍历可能的搜索起点
        for (int i = start; i <= n; i++) {
            // 向路径变量里添加一个数
            path.addLast(i);
            // 下一轮搜索，设置的搜索起点要加 1，因为组合数理不允许出现重复的元素
            dfs(n, k, i + 1, path, res);
            // 重点理解这里：深度优先遍历有回头的过程，因此递归之前做了什么，递归之后需要做相同操作的逆向操作
            path.removeLast();
        }
    }
}
```

##### [【78】子集](https://leetcode-cn.com/problems/subsets/)

方法：回溯

思路： 选与不选

题解：

> - [子集回溯算法，DFS](https://leetcode-cn.com/problems/subsets/solution/zi-ji-hui-su-suan-fa-dfs-by-wei-xiao-shi-cloz/)

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        dfs(ans, path, nums, 0);
        return ans;
    }

    private void dfs(List<List<Integer>> ans, List<Integer> path, int[] nums, int idx) {
        if (idx == nums.length) {
            // 遍历完所有元素，本次搜索结束，将本次结果添加到最终结果集
            ans.add(new ArrayList<>(path));
            return;
        }

        // 挑选当前数
        path.add(nums[idx]);
        dfs(ans, path, nums, idx + 1);
        path.remove(path.size() - 1);

        // 跳过当前数
        dfs(ans, path, nums, idx + 1);

    }
}
```

##### [【79】 单词搜索](https://leetcode-cn.com/problems/word-search/)

方法：回溯

思路： 当前元素匹配后，继续往其他方向匹配

题解：

```java
class Solution {

    public boolean exist(char[][] board, String word) {
        int h = board.length, w = board[0].length;
        // 存储一次回溯中元素的访问状态
        boolean[][] visited = new boolean[h][w];
        for (int i = 0; i < h; i++) {
            for (int j = 0; j < w; j++) {
                // 回溯
                boolean flag = check(board, visited, i, j, word, 0);
                if (flag) {
                    return true;
                }
            }
        }
        return false;
    }

    public boolean check(char[][] board, boolean[][] visited, int i, int j, String word, int k) {
        if (board[i][j] != word.charAt(k)) {
            return false;
        } else if (k == word.length() - 1) {
            return true;
        }
        // 访问当前元素
        visited[i][j] = true;
        // 定义移动的方向
        int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        boolean result = false;
        for (int[] dir : directions) {
            int newi = i + dir[0], newj = j + dir[1];
            if (newi >= 0 && newi < board.length && newj >= 0 && newj < board[0].length) {
                if (!visited[newi][newj]) {
                    // 向其他方向上进行深度优先搜索
                    boolean flag = check(board, visited, newi, newj, word, k + 1);
                    if (flag) {
                        result = true;
                        break;
                    }
                }
            }
        }
        // 重置状态
        visited[i][j] = false;
        return result;
    }

}
```
