---
tags:
  - 算法
  - 双指针
---
# 双指针

#### [【15】三数之和](https://leetcode-cn.com/problems/3sum)

方法：排序 + 双指针

题解：

> - [排序 + 双指针，逐行解释](https://leetcode-cn.com/problems/3sum/solution/pai-xu-shuang-zhi-zhen-zhu-xing-jie-shi-python3-by/)
> - [画解算法：15. 三数之和](https://leetcode-cn.com/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/)

算法流程：

1. 特判，对于数组长度 n*n*，如果数组为 null*n**u**l**l* 或者数组长度小于 33，返回 [][]。
2. 对数组进行排序。
3. 遍历排序后数组：
   - 若 nums[i]>0*n**u**m**s*[*i*]>0：因为已经排序好，所以后面不可能有三个数加和等于 00，直接返回结果。
   - 对于重复元素：跳过，避免出现重复解
   - 令左指针 L=i+1*L*=*i*+1，右指针 R=n-1*R*=*n*−1，当 L<R*L*<*R* 时，执行循环：
     - 当 nums[i]+nums[L]+nums[R]==0nums[i]+nums[L]+nums[R]==0，执行循环，判断左界和右界是否和下一位置重复，去除重复解。并同时将 L,RL,R 移到下一位置，寻找新的解
     - 若和大于 00，说明 nums[R]*n**u**m**s*[*R*] 太大，R*R* 左移
     - 若和小于 00，说明 nums[L]*n**u**m**s*[*L*] 太小，L*L* 右移

```java
class Solution {
    public static List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans = new ArrayList();
        int len = nums.length;
        if(nums == null || len < 3) return ans;
        Arrays.sort(nums); // 排序
        for (int i = 0; i < len ; i++) {
            if(nums[i] > 0) break; // 如果当前数字大于0，则三数之和一定大于0，所以结束循环
            if(i > 0 && nums[i] == nums[i-1]) continue; // 去重
            int L = i+1;
            int R = len-1;
            while(L < R){
                int sum = nums[i] + nums[L] + nums[R];
                if(sum == 0){
                    ans.add(Arrays.asList(nums[i],nums[L],nums[R]));
                    while (L<R && nums[L] == nums[L+1]) L++; // 去重
                    while (L<R && nums[R] == nums[R-1]) R--; // 去重
                    L++;
                    R--;
                }
                else if (sum < 0) L++;
                else if (sum > 0) R--;
            }
        }
        return ans;
    }
}

```

#### [【16】最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)

方法：排序 + 双指针

思路：与三数之和类似，排序 + 双指针

题解：[画解算法：16. 最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/solution/hua-jie-suan-fa-16-zui-jie-jin-de-san-shu-zhi-he-b/)

```java
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int ans = nums[0] + nums[1] + nums[2];
        for(int i=0;i<nums.length;i++) {
            int start = i+1, end = nums.length - 1;
            while(start < end) {
                int sum = nums[start] + nums[end] + nums[i];
                if(Math.abs(target - sum) < Math.abs(target - ans))
                    ans = sum;
                if(sum > target)
                    end--;
                else if(sum < target)
                    start++;
                else
                    return ans;
            }
        }
        return ans;
    }
}
```

#### [【18】四数之和](https://leetcode-cn.com/problems/4sum/)

方法：排序 + 双指针

思路：

排序 + 双指针，与三数之和类似，三数之和基础上再套一层循环

> - 三数之和：一层循环确定1数，再在一层循环内使用双指针确定两数
> - 四数之和：两层循环确定2数，再在一层循环内使用双指针确定两数
> - n数之和：n-2层循环确定n-2数，再在一层循环内使用双指针确定两数

拓展：n数之和

题解：

```java
class Solution {

    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> quadruplets = new ArrayList<>();
        if (nums == null || nums.length < 4) {
            return quadruplets;
        }
        // 1.排序
        Arrays.sort(nums);

        int length = nums.length;
        for (int i = 0; i < length - 3; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) {
                // 同一层循环中，如果当前元素与上一个元素相同，则跳过当前元素。
                continue;
            }
            if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) {
                // 由于已排序，因此若最小的四元组仍大于target，则必一致大于target，故直接退出
                break;
            }
            if (nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] < target) {
                // 由于已排序，若最大的四元组仍小于target，则必一致小于target，故直接退出
                continue;
            }
            for (int j = i + 1; j < length - 2; j++) {
                // 下面的校验同上
                if (j > i + 1 && nums[j] == nums[j - 1]) {
                    continue;
                }
                if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) {
                    break;
                }
                if (nums[i] + nums[j] + nums[length - 2] + nums[length - 1] < target) {
                    continue;
                }
                // 2.双指针
                int left = j + 1, right = length - 1;
                while (left < right) {
                    int sum = nums[i] + nums[j] + nums[left] + nums[right];
                    if (sum == target) {
                        quadruplets.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));
                        // 左指针右移
                        while (left < right && nums[left] == nums[left + 1]) {
                            left++;
                        }
                        left++;
                        // 右指针左移
                        while (left < right && nums[right] == nums[right - 1]) {
                            right--;
                        }
                        right--;
                    } else if (sum < target) {
                        // 和小于target，左指针右移
                        left++;
                    } else {
                        // 和大于target，右指针左移
                        right--;
                    }
                }
            }
        }
        return quadruplets;
    }
}
```

#### [【75】 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

方法：双指针

思路： 遇到0往前放，遇到2往后放，遇到1跳过

题解：

```java
class Solution {
    public void sortColors(int[] nums) {
        if (nums == null || nums.length == 0) {
            return;
        }
        int left = 0, right = nums.length - 1;
        for (int i = 0; i <= right; ) {
            if (nums[i] == 0) {
                // 遇到0往前放
                if (i == left) {
                    i++;
                } else {
                    swap(nums, i, left);
                }
                left++;
            } else if (nums[i] == 2) {
                // 遇到2往后放
                swap(nums, i, right);
                right--;
            } else {
                // 遇到1跳过
                i++;
            }
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

#### [【283】 移动零](https://leetcode-cn.com/problems/move-zeroes/)

方法：双指针

思路： 左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。这样，左指针左边均为非零数；右指针左边直到左指针处均为零。

题解：

```java
class Solution {

    public void moveZeroes(int[] nums) {
        int size = nums.length;
        int l = 0;
        for (int i = 0; i < size; i++) {
            if (nums[i] != 0) {
                swap(nums, i, l);
                l++;
            }
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

#### [【287】 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)

方法：双指针-快慢指针

思路： 快慢指针、Floyd 判圈算法

题解：

```java
class Solution {

    /**
     * 方法：原地哈希
     * <p>
     * 此方法会修改原数组
     *
     * @param nums nums
     * @return result
     */
    public int findDuplicate(int[] nums) {
        int size = nums.length;
        for (int i = 0; i < size; i++) {
            while (nums[i] != i) {
                if (nums[i] == nums[nums[i]]) {
                    return nums[i];
                }
                swap(nums, i, nums[i]);
            }
        }
        return -1;
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }


    /**
     * 方法：二分查找法
     * <p>
     * 此方法会修改原数组
     *
     * @param nums nums
     * @return result
     */
    public int findDuplicate2(int[] nums) {
        int size = nums.length;
        int l = 1, r = size - 1, ans = -1;
        while (l <= r) {
            int mid = (l + r) >> 1;
            // 计算数组中小于等于 mid 的值个数
            int cnt = 0;
            for (int i = 0; i < size; ++i) {
                if (nums[i] <= mid) {
                    cnt++;
                }
            }
            // 移动左右边界
            if (cnt <= mid) {
                // 若 cnt 小于等于 mid，根据抽屉原理，则重复数字在右侧
                l = mid + 1;
            } else {
                // 若 cnt 大于 mid，根据抽屉原理，则重复数字在左侧
                r = mid - 1;
                ans = mid;
            }
        }
        return ans;
    }

    /**
     * 方法：快慢指针-Floyd 判圈算法
     *  (1) 链表
     *  我们将数组当做一个链表，数组的下标就是指向元素的指针，而数组元素的值同时又是一个下标。
     *  如，i=0 是指针，指向 nums[0], 而 nums[0] 也是指针，指向 nums[nums[0]]
     *  （2）Floyd 判圈算法
     *  这样问题转化为求链表中环的起点问题，可用Floyd 判圈算法
     *
     * @param nums
     * @return
     */
    public int findDuplicate3(int[] nums) {
        int slow = 0, fast = 0;
        // 先让慢指针每次走一步，快指针每次走两步
        // 根据 [Floyd 判圈算法，链表有环时，快慢指针一定会相遇
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);

        // 相遇后，将慢指针放置到起点
        // 然后两个指针每次同时走一步，最终相遇的点即是环的起点
        slow = 0;
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }

}
```

#### [【581】 最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)

方法：排序 + 双指针

思路：

题解：

```java
class Solution {

    /**
     * 方法：排序 + 双指针
     * 将数组 numsnums 进行排序，然后与原数组比较，找到最左边和最右边不匹配的元素，即可确定左右边界
     *
     * @param nums nums
     * @return 最短无序连续子数组的长度
     */
    public int findUnsortedSubarray(int[] nums) {
        // 排序
        int[] sortedNums = nums.clone();
        Arrays.sort(sortedNums);
        // 寻找左右边界
        int l = nums.length -1;
        int r = 0;
        for (int i = 0; i < nums.length; i++) {
            if (sortedNums[i] != nums[i]) {
                l = Math.min(l, i);
                r = Math.max(r, i);
            }
        }
        return r - l > 0 ? r - l + 1 : 0;
    }

    /**
     * 方法：排序 + 双指针
     * 同上
     * 将数组 numsnums 进行排序，然后与原数组比较，找到最左边和最右边不匹配的元素，即可确定左右边界
     *
     * @param nums nums
     * @return 最短无序连续子数组的长度
     */
    public int findUnsortedSubarray2(int[] nums) {
        // 排序
        int[] sortedNums = nums.clone();
        Arrays.sort(sortedNums);
        // 找到左边界
        int l = nums.length -1;
        for (int i = 0; i < nums.length; i++) {
            if (sortedNums[i] != nums[i]) {
                l = i;
                break;
            }
        }
        // 找到右边界
        int r = 0;
        for (int i = nums.length-1; i >= 0; i--) {
            if (sortedNums[i] != nums[i]) {
                r = i;
                break;
            }
        }
        return r - l > 0 ? r - l + 1 : 0;
    }

}

```
