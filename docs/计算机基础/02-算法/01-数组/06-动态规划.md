---
tags:
  - 算法
  - 动态规划
---
# 动态规划

动态规划常见题型：

> - 求最值，求最优解
> - 多阶段决策问题

动态规划的解法可尝试使用滚动数组优化

题眼：

##### [【42】 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

方法：解法一：暴力解法

思路： 对于每一列，该列的接水量等于两边最大高度的较小值减去当前列的高度值，也即  `int h = Math.min(lMaxHeight, rMaxHeight) - height[i]`

题解：

> - [接雨水](https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode/)

```java
class Solution {

    public int trap(int[] height) {
        int sum = 0;
        for (int i = 0; i < height.length; i++) {
            // 第一个柱子和最后一个柱子不接雨水
            if (i == 0 || i == height.length - 1) {
                continue;
            }

            // 分别找到当前列左右侧的最高值
            int lMaxHeight = 0, rMaxHeight = 0;
            for (int j = i; j >= 0; j--) {
                lMaxHeight = Math.max(lMaxHeight, height[j]);
            }

            for (int j = i; j < height.length; j++) {
                rMaxHeight = Math.max(rMaxHeight, height[j]);
            }

            // 当前列对应的接水量
            int h = Math.min(lMaxHeight, rMaxHeight) - height[i];
            if (h > 0) {
                sum += h;
            }
        }
        return sum;
    }
}
```

方法：动态规划

思路： 在暴力方法中，我们仅仅为了找到最大值每次都要向左和向右扫描一次。但是我们可以通过动态规划提前存储这个值。

这个值的 DP方程为：` lMaxHeight[i] =  Math.max(height[i], lMaxHeight[i-1] )`

题解：

```java
   /**
     * 解法二：动态规划
     *
     * @param height height
     * @return 接水量
     */
    public int dpTrap(int[] height) {
        int size = height.length;
        if (size == 0) {
            return 0;
        }

        // 构造数组来存放左右侧最高值
        int[] lMaxHeight = new int[size];
        lMaxHeight[0] = height[0];
        for (int i = 1; i < size; i++) {
            lMaxHeight[i] = Math.max(height[i], lMaxHeight[i - 1]);
        }

        int[] rMaxHeight = new int[size];
        rMaxHeight[size - 1] = height[size - 1];
        for (int i = size - 2; i >= 0; i--) {
            rMaxHeight[i] = Math.max(height[i], rMaxHeight[i + 1]);
        }

        // 计算接水量
        int sum = 0;
        for (int i = 1; i < size - 1; i++) {
            int h = Math.min(lMaxHeight[i], rMaxHeight[i]) - height[i];
            if (h > 0) {
                sum += h;
            }
        }
        return sum;
    }
```

### 1.连续子数组

#### [【53】 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

方法：动态规划

思路：

（1）确定解题方法

> 题目中说要求最大和，很容易联想到动态规划，并且是求连续子数组，也就是说每一步都需要用到上一步的结果，因此确定了可以用动态规划解题。
>
> DP方程为：max_sum(i) = num[i] +max_sum[i-1]

题解：

```java
class Solution {

    /**
     * 解法一：动态规划
     *
     * @param nums nums
     * @return 最大子序和
     */
    public int maxSubArray1(int[] nums) {
        int size = nums.length;
        if (size == 0) {
            return 0;
        }

        // 构建DP状态数组
        int[] maxSum = new int[size];
        maxSum[0] = nums[0];
        for (int i = 1; i < size; i++) {
            maxSum[i] = Math.max(maxSum[i - 1] + nums[i], nums[i]);
            System.out.println(maxSum[i]);
        }

        // 计算结果
        int result = maxSum[0];
        for (int i = 0; i < size; i++) {
            result = Math.max(maxSum[i], result);
        }
        return result;
    }

    /**
     * 解法一：动态规划 + 滚动数组
     * 考虑到 f(i) 只和 f(i-1) 相关，于是我们可以只用一个变量 textitpre  来维护对于当前 f(i) 的 f(i-1) 的值是多少，从而让空间复杂度降低到 O(1)
     *
     * @param nums nums
     * @return 最大子序和
     */
    public int maxSubArray2(int[] nums) {
        int size = nums.length;
        if (size == 0) {
            return 0;
        }

        int pre = 0, result = nums[0];
        for (int num : nums) {
            pre = Math.max(pre + num, num);
            result = Math.max(result, pre);
        }

        return result;
    }
}
```

#### [【152】 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

思路：

（1）确定解题方法

> 题目中说要求最值，很容易联想到动态规划，并且是求连续子数组，也就是说每一步都需要用到上一步的结果，因此确定了可以用动态规划解题。
>
> DP方程为：
>
> ```java
> dpMax[i] = max(nums[i], dpMin[i - 1] * nums[i], dpMax[i - 1] * nums[i])
> dpMin[i] = min(nums[i], dpMin[i - 1] * nums[i], dpMax[i - 1] * nums[i])
> ```

题解：

```java
class Solution {

    /**
     * 若全为正数：则最大乘积： dpMax[i] = max(nums[i], dpMax[i - 1] * nums[i])
     * 但是由于数组中可能存在负数，后一个负数会与前一个负数抵消，负负得正
     * 并且上一个负数越小，乘积就越大，因此还需记录最小值，因此得出DP：
     *     dpMax[i] = max(nums[i], dpMin[i - 1] * nums[i], dpMax[i - 1] * nums[i]);
     *     dpMin[i] = min(nums[i], dpMin[i - 1] * nums[i], dpMax[i - 1] * nums[i]);
     *   
     * @param nums 目标数组
     * @return 乘积
     */
    public int maxProduct(int[] nums) {
        int size = nums.length;

        // 构建DP状态数组
        int[] dpMax = new int[size];
        int[] dpMin = new int[size];
        dpMax[0] = nums[0];
        dpMin[0] = nums[0];

        for (int i = 1; i < size; ++i) {
            // 计算最大、最小值
            dpMax[i] = max(nums[i], dpMin[i - 1] * nums[i], dpMax[i - 1] * nums[i]);
            dpMin[i] = min(nums[i], dpMin[i - 1] * nums[i], dpMax[i - 1] * nums[i]);
        }

        // 计算结果：求最大值
        int result = dpMax[0];
        for (int i = 1; i < size; ++i) {
            result = Math.max(result, dpMax[i]);
        }

        return result;
    }

    private int max(int a, int b, int c) {
        return Math.max(a, Math.max(b, c));
    }

    private int min(int a, int b, int c) {
        return Math.min(a, Math.min(b, c));
    }

}
```

#### [【62】 不同路径](https://leetcode-cn.com/problems/unique-paths/)

方法：动态规划

思路：除了起始位置、第一行、第一列，其他行列的位置都是由上一行或者前一列移动而来，状态转移方程为：`f(i, j) = f(i-1, j) + f(i, j-1)`

题解：

```java
class Solution {

    public int uniquePaths(int m, int n) {
        int[][] res = new int[m][n];
        for(int i = 0;i< m;i++){
            for (int j =0; j<n; j++){
                if(i == 0 && j== 0){
                    // 起始值
                    res[i][j] = 1;
                }else if(i == 0){
                    // 第一行
                    res[i][j] = res[i][j-1] ;
                }else if(j == 0){
                    // 第一列
                    res[i][j] = res[i-1][j] ;
                }else {
                    // 其他行列
                    //动态规划状态转移方程： f(i, j) = f(i-1, j) + f(i, j-1)
                    res[i][j] = res[i-1][j] +  res[i][j-1];
                }
            }
        }
        return res[m-1][n-1];
    }
}
```

#### [【64】 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

方法：动态规划

思路：除了起始位置、第一行、第一列，其他行列的位置都是由上一行或者前一列移动而来，状态转移方程为：

```java
dp[i][j] = min(dp[i-1,j], dp[i,j-1]) + grid[i][j]
```

题解：

```java
class Solution {
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m][n];

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 && j == 0) {
                    // 起始值
                    dp[i][j] = grid[i][j];
                } else if (i == 0) {
                    // 第一行
                    dp[i][j] = dp[i][j - 1] + grid[i][j];
                } else if (j == 0) {
                    // 第一列
                    dp[i][j] = dp[i - 1][j] + grid[i][j];
                } else {
                    // 动态规划状态转移方程： dp[i][j] = min(dp[i-1,j], dp[i,j-1]) + grid[i][j]
                    dp[i][j] = Math.min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];
                }
            }
        }
        return dp[m - 1][n - 1];
    }
}
```

### 2.前缀和

推荐阅读：

> - [【动画模拟】秒杀七道题](https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/de-liao-yi-wen-jiang-qian-zhui-he-an-pai-yhyf/)
> - 

前缀和思想和滑动窗口会经常用在求子数组和子串问题上

#### [【560】 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

方法：前缀和 + 哈希表

思路：

题解：

```java
class Solution {

    /**
     * 方法： 前缀和
     * 我们定义 pre[i] 为 [0..i] 里所有数的和，若已知 [j+1..i] 这个子数组和为k，则可得  pre[j] = pre[i] - k
     * <p>
     * 因此我们可将 `求以 i 结尾的和为k的连续子数组的个数的问题` 转化为 `求前缀和 pre[i] - k 的个数`。
     *
     * @param nums nums
     * @param k    和为k
     * @return 和为K的子数组个数
     */
    public int subarraySum(int[] nums, int k) {
        int size = nums.length;
        int pre = 0;
        int count = 0;

        // k: 和, v: 和出现的个数
        Map<Integer, Integer> map = new HashMap<>();
        // 确保nums[0]==k时，会作为一个符合条件的子数组进行计数
        map.put(0, 1);
        for (int i = 0; i < size; i++) {
            // preSum[i] 表示[0..i]的和
            pre += nums[i];
            // preSum[j] 是否存在
            if (map.containsKey(pre - k)) {
                // 有多少个 preSum[j], 就有多少种前缀和为k的子数组
                count += map.get(pre - k);
            }
            // 记录  preSum[i] 出现的次数，供后面的 i 使用
            map.put(pre, map.getOrDefault(pre, 0) + 1);
        }
        return count;
    }
}

```

#### [【523】 连续的子数组和](https://leetcode-cn.com/problems/continuous-subarray-sum/)

方法：前缀和 + 哈希表

思路：

题解：

```java
class Solution {

    /**
     * 方法： 前缀和
     * 我们定义 preSum[i] 为 [0..i] 里所有数的和，若已知 [j+1..i] 这个子数组和为k的倍数，
     * 则可得区间和 sum = preSum[i] - preSum[j] = n * k
     *
     * 先构建前缀和数组，然后根据前缀和数组来计算区间和
     * sum = preSum[i] - preSum[j]  ,然后判断区间和sum是否满足要求
     *
     * 时间 O(n^2) 会超时， 空间 O(n)
     *
     * @param nums nums
     * @param k    和为k
     * @return 该数组是否含有连续的子数组
     */
    public boolean checkSubarraySum(int[] nums, int k) {
        int len = nums.length;

        // 构造前缀和数组
        // preSum[i] 表示：区间 [0..i) 的前缀和
        int[] preSum = new int[len + 1];
        preSum[0] = 0;
        for (int i = 0; i < len; i++) {
            preSum[i + 1] = preSum[i] + nums[i];
        }

        // 根据前缀和计算区间和
        for (int left = 0; left < len - 1; left++) {
            for (int right = left + 1; right < len; right++) {
                int sum = preSum[right + 1] - preSum[left];
                if (sum == k || (k != 0 && sum % k == 0)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * 方法： 前缀和 +  哈希表
     *
     * 当 余数1 等于 余数2时，
     * preSum[i] = 常数1 * k + 余数1
     * preSum[j] = 常数2 * k + 余数2
     * 易得区间和 sum =  preSum[i] - preSum[j] = n * k
     *
     * 于是跟 560 题类似，可将此题转化为求 是否存在 前缀和 preSum[j] 满足其余数等于 preSum[i] 的余数
     *
     * @param nums nums
     * @param k    和为k
     * @return 该数组是否含有连续的子数组
     */
    public boolean checkSubarraySum2(int[] nums, int k) {
        int size = nums.length;
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, -1);

        int preSum = 0;
        for (int i = 0; i < size; i++) {
            // 计算前缀和
            preSum += nums[i];
            // 计算前缀和余数
            int rem = preSum % k;
            if (map.containsKey(rem)) {
                // 当已存在余数时，判断子数组长度是否大于2
                if (i - map.get(rem) > 1) {
                    return true;
                }
            } else {
                map.put(rem, i);
            }
        }
        return false;
    }
}
```

#### [【724】 寻找数组的中心下标](https://leetcode-cn.com/problems/find-pivot-index/)

方法：前缀和

思路：

题解：

```java
    /**
     * 方法： 前缀和
     *
     * 我们定义 pre[i] 为 [0..i] 里所有数的和，则:
     *  leftSum  = preSum - nums[i]
     *  rightSum = total - preSum
     *
     * @param nums nums
     * @return 中心下标
     */
    public int pivotIndex(int[] nums) {
        int size = nums.length;

        int total = Arrays.stream(nums).sum();
        int preSum = 0;
        for (int i = 0; i < size; i++) {
            // 滚动前缀和
            preSum += nums[i];
            // 根据前缀和计算左侧和与右侧和
            int leftSum = preSum - nums[i];
            int rightSum = total - preSum;
            if (leftSum == rightSum) {
                return i;
            }
        }
        return -1;
    }
```

#### [【974】 和可被 K 整除的子数组](https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/)

方法：前缀和

思路：

题解：

```java
class Solution {

    /**
     * 方法： 前缀和 + 哈希
     * preSum[j] = 常数1*K + 余数1
     * preSum[i] = 常数2*K + 余数2
     * 区间和 sum = preSum[i] - preSum[j] = 常数3 * K + (余数1-余数2)
     * <p>
     * 当 余数1 = 余数2 时，则子数组[j+1, i]的和可被 K 整除，然后计算一下 count 即可
     *
     * @param A nums
     * @return 元素之和可被 K 整除的（连续、非空）子数组的数目。
     */
    public int subarraysDivByK(int[] A, int K) {
        int size = A.length;

        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);
        int preSum = 0;
        int count = 0;
        for (int i = 0; i < size; i++) {
            preSum += A[i];
            // 注意 Java 取模的特殊性，当被除数为负数时取模结果为负数，需要纠正
            int rem = (preSum % K + K) % K;
            if (map.containsKey(rem)) {
                count += map.get(rem);
            }
            map.put(rem, map.getOrDefault(rem, 0) + 1);
        }
        return count;
    }
}

```

### 3.买卖股票问题

#### [【121】 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/) - 期间内只能进行一次交易

方法：动态规划

思路：

解答动态规划相关问题的时候，需要先考虑影响因素，根据影响因素构建多元组。

本题可转化为买卖股票问题通解的k=1形式

题解：

> - [暴力解法、动态规划（Java）](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/bao-li-mei-ju-dong-tai-gui-hua-chai-fen-si-xiang-b/)

拓展：

买卖股票问题的通解：

> - [股票问题系列通解（转载翻译）](https://leetcode-cn.com/circle/article/qiAgHn/)
> - [算法 | 《买卖股票的最佳时机》系列问题](https://www.jianshu.com/p/86d1b8befcd4)
> - 

```java
/**
 * title: 121. 买卖股票的最佳时机 - 只能买卖一次
 *
 *
 * 推荐阅读：[算法 | 《买卖股票的最佳时机》系列问题](https://www.jianshu.com/p/86d1b8befcd4)
 *
 * 买卖股票通解：
 *
 * 动态规划： 动态规划的题目需要先分析影响因素，然后根据影响因素构建n维dp数组
 *
 *  （1） 定义状态：
 *       dp[i][k][j],   0 <= i <= n-1, 1 <= k <= K, j=0或1， 分别表示：
 *          - n: 天数
 *          - K: 允许的最大交易次数
 *          - j：持有j份股票
 *
 *       因此通解方程为：
 *          dp[i][k][j] = max(buy, sell, rest)
 *
 *  （2） 状态转移方程：
 *      // 第i天，交易了k次，持有0份股票
 *      - dp[i][k][0] = max( dp[i-1][k][0], dp[i-1][k][1] + prices[i])   :  max{ rest, sell }
 *
 *      // 第i天，交易了k次，持有1份股票
 *      - dp[i][k][1] = max( dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) :  max{ rest, buy }
 *
 *   (3) 基态
 *        dp[0][k][0] = 0;
 *        dp[0][k][1] = -prices[0];
 *
 * @author shira 2019/07/09 22:57
 */
class Solution {


    /**
     *
     * 本题相当于通解的特殊形式：
     *      - K=1  : 只能买卖一次
     *      - k 为常量，不会改变，因此不用作为影响因素
     *
     * 因此将通解简化为如下形式：
     *
     *  （1） 定义状态：
     *       dp[i][j],   0 <= i <= n-1,j=0或1， 分别表示：
     *          - n: 天数
     *          - j：持有j份股票
     *
     *       因此通解方程为：
     *          dp[i][j] = max(buy, sell, rest)

     *  （2） 状态转移方程：
     *      // 第i天，持有0份股票
     *      - dp[i][0] = max( dp[i-1][0], dp[i-1][1] + prices[i])   :  max{ rest, sell }
     *
     *      // 第i天，持有1份股票
     *      // 由于只能买卖一次，因此若昨天不持有，则说明昨天之前都不持有，则 dp[i−1][0] = dp[0][0] = 0
     *      - dp[i][1] = max( dp[i-1][1], dp[i-1][0] - prices[i]) = max( dp[i-1][1], - prices[i]) :  max{ rest, buy }
     *
     *  (3) 基态
     *        dp[0][0] = 0;
     *        dp[0][1] = -prices[0];
     *
     * @param prices 股票每一天的价格
     * @return
     */
    public int maxProfit(int prices[]) {
        if (prices == null || prices.length == 0) {
            return 0;
        }

        int[][] dp = new int[prices.length][2];

        // 基态，将第一天买卖的情况作为初始值
        dp[0][0] = 0;
        dp[0][1] = -prices[0];

        for (int i = 1; i < prices.length; i++) {
            // 当天不持股手上的现金数等于如下两种方案的最大值：
            //    - 前一天不持股，今天继续不持股，无交易，则手上的现金数等于昨天不持股的现金数
            //    - 前一天持股，今天卖出，手上的现金数等于昨天持股的现金数 + 今天股票卖出的价格
            // -----------------------------------------------------------------------------------------------------
            // 当天持股手上的现金数等于如下两种方案的最大值：
            //    - 前一天持股，今天继续持股，无交易，则手上的现金数等于昨天持股的现金数
            //    - 前一天不持股，由于只允许交易一次，则说明今天之前从未买过股票，手上的现金数等于开始时拥有现金数( dp[0][0] = 0 )-今天股票买入的价格
            // 动态规划转移方程
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
        }
        return dp[prices.length - 1][0];
    }

    /**
     * 一次遍历：从最低点买进，最高点卖出
     *
     * @param prices
     * @return
     */
    public int maxProfit1(int prices[]) {
        // 记录历史最低价格
        int minprice = Integer.MAX_VALUE;
        // 记录最高利润
        int maxprofit = 0;
        for (int i = 0; i < prices.length; i++) {
            if (prices[i] < minprice) {
                // 更新历史最低价格
                minprice = prices[i];
            } else if (prices[i] - minprice > maxprofit) {
                // 更新最高利润
                maxprofit = prices[i] - minprice;
            }
        }
        return maxprofit;
    }
}
```

#### [【122】 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/) - 期间内可进行多次交易

方法：动态规划

思路：

本题可转化为买卖股票问题通解的k=正无穷形式

题解：

> - [买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-leetcode-s/)

```java
/**
 * title: 122. 买卖股票的最佳时机 II - 可以买卖多次
 *
 * @author shira 2019/07/09 22:57
 */
class Solution {

    /**
     *
     * 本题相当于通解的特殊形式：
     *      - K 趋近于无穷大，既然k趋近于无穷大，说明k不用作为影响因素
     *
     * 因此将通解简化为如下形式：
     *
     *  （1） 定义状态：
     *       dp[i][j],   0 <= i <= n-1,j=0或1， 分别表示：
     *          - n: 天数
     *          - j：持有j份股票
     *
     *       因此通解方程为：
     *          dp[i][j] = max(buy, sell, rest)

     *  （2） 状态转移方程：
     *      // 第i天，持有0份股票
     *      - dp[i][0] = max( dp[i-1][0], dp[i-1][1] + prices[i])   :  max{ rest, sell }
     *
     *      // 第i天，持有1份股票
     *      - dp[i][1] = max( dp[i-1][1], dp[i-1][0] - prices[i])  :  max{ rest, buy }
     *
     *  (3) 基态
     *        dp[0][0] = 0;
     *        dp[0][1] = -prices[0];
     *
     * @param prices 股票每一天的价格
     * @return
     */
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) {
            return 0;
        }
        int size = prices.length;

        int[][] dp = new int[size][2];
        // 基态，将第一天买卖的情况作为初始值
        dp[0][0] = 0;
        dp[0][1] = -prices[0];

        for (int i = 1; i < size; i++) {
            // 动态规划转移方程
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        }
        return dp[size - 1][0];
    }


}
```

#### [【123】 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/) - 期间内可进行两次交易

方法：动态规划

思路：

本题可转化为买卖股票问题通解的k=任意正整数

题解：

```java
/**
 * title: 123. 买卖股票的最佳时机 III - 只能买卖两次
 *
 * @author shira 2019/07/09 22:57
 */
class Solution {

    /**
     * 本题相当于通解的特殊形式：
     *      - K=为任意正整数  : 本题是K=2
     *
     * 买卖股票通解：
     *
     * 动态规划： 动态规划的题目需要先分析影响因素，然后根据影响因素构建n维dp数组
     *
     *  （1） 定义状态：
     *       dp[i][k][j],   0 <= i <= n-1, 1 <= k <= K, j=0或1， 分别表示：
     *          - n: 天数
     *          - K: 允许的最大交易次数, K=2
     *          - j：持有j份股票
     *
     *       因此通解方程为：
     *          dp[i][k][j] = max(buy, sell, rest)
     *
     *  （2） 状态转移方程：
     *      // 第i天，交易了k次，持有0份股票
     *      - dp[i][k][0] = max( dp[i-1][k][0], dp[i-1][k][1] + prices[i])   :  max{ rest, sell }
     *
     *      // 第i天，交易了k次，持有1份股票
     *      - dp[i][k][1] = max( dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) :  max{ rest, buy }
     *
     *   (3) 基态
     *        dp[0][k][0] = 0;
     *        dp[0][k][1] = -prices[0];
     *
     *
     * @param prices 股票每一天的价格
     * @return
     */
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) {
            return 0;
        }
        int size = prices.length;

        int[][][] dp = new int[size][3][2];
        // 基态，将第一天买卖的情况作为初始值
        dp[0][0][0] = 0;
        dp[0][1][0] = 0;
        dp[0][1][1] = -prices[0];
        dp[0][2][0] = 0;
        dp[0][2][1] = -prices[0];

        for (int i = 1; i < size; i++) {
            for (int k = 1; k <= 2; k++) {
                // 动态规划转移方程
                dp[i][k][0] = Math.max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]);
                dp[i][k][1] = Math.max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i]);
            }
        }
        return dp[size - 1][2][0];
    }

    /**
     * 时间，空间优化
     * @param prices
     * @return
     */
    public int maxProfit2(int[] prices) {
        if (prices == null || prices.length == 0) {
            return 0;
        }
        int size = prices.length;

        // 基态，将第一天买卖的情况作为初始值
        int buy1 = -prices[0], sell1 = 0;
        int buy2 = -prices[0], sell2 = 0;

        for (int i = 1; i < size; i++) {
            // 两次买卖
            buy1 = Math.max(buy1, -prices[i]);
            sell1 = Math.max(sell1, buy1 + prices[i]);
            buy2 = Math.max(buy2, sell1 - prices[i]);
            sell2 = Math.max(sell2, buy2 + prices[i]);
        }
        return sell2;
    }
}
```

#### [【188】 买卖股票的最佳时机 IV- 期间内可进行k次交易](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

方法：动态规划

思路：

本题就是求买卖股票问题的通解，不过需要注意最大交易次数的临界值

题解：

```java
/**
 * title: 188. 买卖股票的最佳时机 IV - 买卖k次
 *
 * @author shira 2019/07/09 22:57
 */
class Solution {

    /**
     * 本题就是求买卖股票问题的通解:
     *
     * 但是需要注意当k的次数非常大时，dp数组也会随之非常大。现在来考虑下k的最大值；
     *      - 显然，如果 k 超过一个临界值，最大收益就不再取决于允许的最大交易次数
     *      - 一个有收益的交易至少需要两天，也就是说有效的 k 应该限制为不超过 n/2，
     *      - 如果超过，就没有约束作用了，相当于 k = +infinity
     *
     * 动态规划： 动态规划的题目需要先分析影响因素，然后根据影响因素构建n维dp数组
     *
     *  （1） 定义状态：
     *       dp[i][k][j],   0 <= i <= n-1, 1 <= k <= K, j=0或1， 分别表示：
     *          - n: 天数
     *          - K: 允许的最大交易次数, K=k
     *          - j：持有j份股票
     *
     *       因此通解方程为：
     *          dp[i][k][j] = max(buy, sell, rest)
     *
     *  （2） 状态转移方程：
     *      // 第i天，交易了k次，持有0份股票
     *      - dp[i][k][0] = max( dp[i-1][k][0], dp[i-1][k][1] + prices[i])   :  max{ rest, sell }
     *
     *      // 第i天，交易了k次，持有1份股票
     *      - dp[i][k][1] = max( dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) :  max{ rest, buy }
     *
     *   (3) 基态
     *        dp[0][k][0] = 0;
     *        dp[0][k][1] = -prices[0];
     *
     *
     * @param prices 股票每一天的价格
     * @return
     */
    public int maxProfit(int k, int[] prices) {
        if (prices == null || prices.length == 0) {
            return 0;
        }
        int size = prices.length;
        if (k >= size / 2) {
            // 当k超过临界值时，k就没有约束作用了，相当于 k = +infinity，等效于 【122. 买卖股票的最佳时机 II - 可以买卖多次】
            return maxProfit(prices);
        }

        int[][][] dp = new int[size][k+1][2];
        // 基态，将第一天买卖的情况作为初始值
        for(int i =1;i<=k;i++){
            dp[0][i][0] = 0;
            dp[0][i][1] = -prices[0];
        }

        for (int i = 1; i < size; i++) {
            for (int j = 1; j <= k; j++) {
                // 动态规划转移方程
                dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);
                dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);
            }
        }
        return dp[size - 1][k][0];
    }


    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) {
            return 0;
        }
        int size = prices.length;

        int[][] dp = new int[size][2];
        // 基态，将第一天买卖的情况作为初始值
        dp[0][0] = 0;
        dp[0][1] = -prices[0];

        for (int i = 1; i < size; i++) {
            // 动态规划转移方程
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        }
        return dp[size - 1][0];
    }

}
```

#### [【309】 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

方法：动态规划

思路：

本题可转化为买卖股票问题通解的K为正无穷但有冷却期形式

题解：

```java
/**
 * title: 309. 最佳买卖股票时机含冷冻期
 *
 * @author shira 2019/07/09 22:57
 */
class Solution {

    /**
     * 本题相当于通解的特殊形式：
     *     - K为正无穷但有冷却期
     *
     * 动态规划： 动态规划的题目需要先分析影响因素，然后根据影响因素构建n维dp数组
     *
     *  （1） 定义状态：
     *       dp[i][k][j],   0 <= i <= n-1, 1 <= k <= K, j=0或1， 分别表示：
     *          - n: 天数
     *          - K: 允许的最大交易次数, K=k
     *          - j：持有j份股票
     *
     *       因此通解方程为：
     *          dp[i][k][j] = max(buy, sell, rest)
     *
     *  （2） 状态转移方程：
     *      // 第i天，交易了k次，持有0份股票
     *      - dp[i][k][0] = max( dp[i-1][k][0], dp[i-1][k][1] + prices[i])   :  max{ rest, sell }
     *
     *      // 第i天，交易了k次，持有1份股票，
     *      // 由于卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)，因此如果想在第i天买入股票，则需要最近一次卖出的时间最早是在i-2天
     *      - dp[i][k][1] = max( dp[i-1][k][1], dp[i-2][k][0] - prices[i]) :  max{ rest, buy }
     *
     *   (3) 基态
     *        dp[0][k][0] = 0;
     *        dp[0][k][1] = -prices[0];
     *
     *
     * @param prices 股票每一天的价格
     * @return
     */
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) {
            return 0;
        }
        int size = prices.length;
        int[][] dp = new int[size][2];

        // 基态
        dp[0][0] = 0;
        dp[0][1] = -prices[0];

        for (int i = 1; i < size; i++) {
            // 动态规划转移方程
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], (i >= 2 ? dp[i - 2][0] : 0) - prices[i]);
        }
        return dp[size - 1][0];
    }


}
```

#### [【714】 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

方法：动态规划

思路：

本题可转化为买卖股票问题通解的K为正无穷但含手续费

题解：

```java
/**
 * title: 714. 买卖股票的最佳时机含手续费
 *
 * @author shira 2019/07/09 22:57
 */
class Solution {

    /**
     * 本题相当于通解的特殊形式：
     *     - K为正无穷但含手续费
     *
     * 动态规划： 动态规划的题目需要先分析影响因素，然后根据影响因素构建n维dp数组
     *
     *  （1） 定义状态：
     *       dp[i][k][j],   0 <= i <= n-1, 1 <= k <= K, j=0或1， 分别表示：
     *          - n: 天数
     *          - K: 允许的最大交易次数, K=k
     *          - j：持有j份股票
     *
     *       因此通解方程为：
     *          dp[i][k][j] = max(buy, sell, rest)
     *
     *  （2） 状态转移方程：
     *      // 第i天，交易了k次，持有0份股票
     *      - dp[i][k][0] = max( dp[i-1][k][0], dp[i-1][k][1] + prices[i])   :  max{ rest, sell }
     *
     *      // 第i天，交易了k次，持有1份股票，每笔交易都需要支付手续费
     *      - dp[i][k][1] = max( dp[i-1][k][1], dp[i-1][k][0] - prices[i] - fee) :  max{ rest, buy }
     *
     *   (3) 基态
     *        dp[0][k][0] = 0;
     *        dp[0][k][1] = -prices[0];
     *
     *
     * @param prices 股票每一天的价格
     * @param fee 股票交易价格
     * @return
     */
    public int maxProfit(int[] prices, int fee) {
        if (prices == null || prices.length == 0) {
            return 0;
        }
        int size = prices.length;
        int[][] dp = new int[size][2];

        // 基态
        dp[0][0] = 0;
        dp[0][1] = -prices[0] - fee;

        for (int i = 1; i < size; i++) {
            // 动态规划转移方程
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee);
        }
        return dp[size - 1][0];
    }


}
```
